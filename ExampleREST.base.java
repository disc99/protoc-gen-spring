// Generated by the protoc-gen-spring compiler plugin.  DO NOT EDIT!
// source: example.proto
package com.echo.v1;

import java.util.Map;
import java.util.List;
import com.google.gson.annotations.SerializedName;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.google.protobuf.ByteString;
import java.util.stream.Collectors;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import io.grpc.ManagedChannel;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import io.swagger.annotations.ApiOperation;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import io.grpc.StatusRuntimeException;
import org.springframework.http.HttpStatus;
import io.grpc.Status;
import io.grpc.Status.Code;
import io.grpc.stub.StreamObserver;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.ArrayList;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;

@javax.annotation.Generated(
    value = "by protoc-gen-spring compiler plugin",
    comments = "Source: example.proto")
public class ExampleREST {
  @ApiModel(value = "EchoRequest", description = "")
  public static class EchoRequest {
    private EchoRequest() {}

    @ApiModel(value = "Sub", description = "")
    public static class Sub {
      private Sub() {}

      @ApiModelProperty(required = false, name = "text", value = "")
      @SerializedName(value = "text")
      @JsonProperty(value = "text")
      public String text_ = null;

      public com.echo.v1.EchoRequest.Sub toProto() {
        com.echo.v1.EchoRequest.Sub.Builder builder = com.echo.v1.EchoRequest.Sub.newBuilder();
        if (text_ != null) {
          builder.setText(text_);
        }

        return builder.build();
      }

      public static Sub fromProto(com.echo.v1.EchoRequest.Sub input) {
        Sub newMsg = new Sub();
        newMsg.text_ = input.getText();

        return newMsg;
      }
    }

    @ApiModelProperty(required = false, name = "message", value = "")
    @SerializedName(value = "message")
    @JsonProperty(value = "message")
    public String message_ = null;

    @ApiModelProperty(required = false, name = "time", value = "")
    @SerializedName(value = "time")
    @JsonProperty(value = "time")
    public com.google.protobuf.TimestampProtoREST.Timestamp time_ = null;

    @ApiModelProperty(required = false, name = "mapField", value = "")
    @SerializedName(value = "mapField")
    @JsonProperty(value = "mapField")
    public Map<Integer, String> mapField_ = null;

    @ApiModelProperty(
        required = false,
        name = "name",
        value =
            "This field belongs to the oneof group: testOneof."
                + "Only one field in the group should be set, or else weird things will happen."
                + "")
    @SerializedName(value = "name")
    @JsonProperty(value = "name")
    public String name_ = null;

    @ApiModelProperty(
        required = false,
        name = "num",
        value =
            "This field belongs to the oneof group: testOneof."
                + "Only one field in the group should be set, or else weird things will happen."
                + "")
    @SerializedName(value = "num")
    @JsonProperty(value = "num")
    public Integer num_ = null;

    @ApiModelProperty(required = false, name = "sub", value = "")
    @SerializedName(value = "sub")
    @JsonProperty(value = "sub")
    public com.echo.v1.ExampleREST.EchoRequest.Sub sub_ = null;

    public com.echo.v1.EchoRequest toProto() {
      com.echo.v1.EchoRequest.Builder builder = com.echo.v1.EchoRequest.newBuilder();
      if (message_ != null) {
        builder.setMessage(message_);
      }

      if (time_ != null) {
        builder.setTime(time_.toProto());
      }

      if (mapField_ != null) {
        builder.putAllMapField(mapField_);
      }

      if (name_ != null) {
        builder.setName(name_);
      }

      if (num_ != null) {
        builder.setNum(num_);
      }

      if (sub_ != null) {
        builder.setSub(sub_.toProto());
      }

      return builder.build();
    }

    public static EchoRequest fromProto(com.echo.v1.EchoRequest input) {
      EchoRequest newMsg = new EchoRequest();
      newMsg.message_ = input.getMessage();
      newMsg.time_ = com.google.protobuf.TimestampProtoREST.Timestamp.fromProto(input.getTime());
      newMsg.mapField_ = input.getMapFieldMap();
      newMsg.name_ = input.getTestOneofCase().getNumber() != 4 ? null : input.getName();
      newMsg.num_ = input.getTestOneofCase().getNumber() != 5 ? null : input.getNum();
      newMsg.sub_ = com.echo.v1.ExampleREST.EchoRequest.Sub.fromProto(input.getSub());

      return newMsg;
    }
  }

  @ApiModel(value = "EchoResponse", description = "")
  public static class EchoResponse {
    private EchoResponse() {}

    @ApiModelProperty(required = false, name = "message", value = "")
    @SerializedName(value = "message")
    @JsonProperty(value = "message")
    public String message_ = null;

    public com.echo.v1.EchoResponse toProto() {
      com.echo.v1.EchoResponse.Builder builder = com.echo.v1.EchoResponse.newBuilder();
      if (message_ != null) {
        builder.setMessage(message_);
      }

      return builder.build();
    }

    public static EchoResponse fromProto(com.echo.v1.EchoResponse input) {
      EchoResponse newMsg = new EchoResponse();
      newMsg.message_ = input.getMessage();

      return newMsg;
    }
  }

  @ApiModel(description = "")
  public enum Type {
    @ApiModelProperty(value = "")
    RED(0),
    @ApiModelProperty(value = "")
    BLUE(1),
    ;

    private final int value;

    private Type(int value) {
      this.value = value;
    }

    public int getValue() {
      return value;
    }

    public com.echo.v1.Type toProto() {
      return com.echo.v1.Type.forNumber(this.value);
    }

    public static Type fromProto(com.echo.v1.Type input) {
      for (Type val : Type.values()) {
        if (val.value == input.getNumber()) {
          return val;
        }
      }
      throw new IllegalStateException("No matching enum for " + input + " in " + Type.values());
    }
  }

  @Api(value = "/EchoService")
  @RestController
  public static class EchoServiceController {
    @ApiModel(
        description =
            "Wrapper around the responses from EchoService to provide optional error information.")
    public static class EchoServiceResponse<T> {
      @ApiModelProperty("If present, the response from the method call. Null IFF error is present.")
      public final T response;

      @ApiModelProperty(
          "If present, the error encountered during the method call. Null IFF response is present.")
      public final String error;

      private EchoServiceResponse() {
        response = null;
        error = null;
      }

      private EchoServiceResponse(T response, String error) {
        this.response = response;
        this.error = error;
      }

      static <T> EchoServiceResponse success(T response) {
        return new EchoServiceResponse(response, null);
      }

      static <T> EchoServiceResponse error(String error) {
        return new EchoServiceResponse(null, error);
      }
    }

    private com.echo.v1.EchoServiceGrpc.EchoServiceImplBase service;

    public EchoServiceController(com.echo.v1.EchoServiceGrpc.EchoServiceImplBase service) {
      this.service = service;
    }

    @ApiOperation(value = "/EchoService/getEcho", notes = "")
    @RequestMapping(
        path = "/EchoService/getEcho",
        method = RequestMethod.POST,
        consumes = {MediaType.APPLICATION_JSON_UTF8_VALUE},
        produces = {MediaType.APPLICATION_JSON_UTF8_VALUE})
    public ResponseEntity<EchoServiceResponse<com.echo.v1.ExampleREST.EchoResponse>> getEcho(
        @RequestBody com.echo.v1.ExampleREST.EchoRequest inputDto) {
      if (service == null) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(
                EchoServiceResponse.error(
                    "The service EchoService was not injected "
                        + "into the RestController. Check that a bean implementing EchoServiceImplBase"
                        + " exists in the Spring configuration."));
      }
      // The plugin code should assign a value to this variable inside input = inputDto.toProto();
      final com.echo.v1.EchoRequest input;
      try {
        // Prepare the "input" field out of the request args.
        // If the "input" field does not get set here, there will be a compilation error.
        input = inputDto.toProto();
      } catch (RuntimeException e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(
                EchoServiceResponse.error(
                    "Failed to prepare input for method getEcho: " + e.getMessage()));
      }
      List<com.echo.v1.ExampleREST.EchoResponse> responseList = new ArrayList<>();
      LinkedBlockingQueue<Status> statusQueue = new LinkedBlockingQueue<>(1);
      StreamObserver<com.echo.v1.EchoResponse> responseObserver =
          new StreamObserver<com.echo.v1.EchoResponse>() {
            @Override
            public void onNext(com.echo.v1.EchoResponse value) {
              responseList.add(com.echo.v1.ExampleREST.EchoResponse.fromProto(value));
            }

            @Override
            public void onError(Throwable t) {
              statusQueue.offer(Status.fromThrowable(t));
            }

            @Override
            public void onCompleted() {
              statusQueue.offer(Status.OK);
            }
          };
      try {
        service.getEcho(input, responseObserver);
      } catch (RuntimeException e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(
                EchoServiceResponse.error(
                    "The method getEcho returned an exception: " + e.getMessage()));
      }
      try {
        Status status = statusQueue.take();
        if (status.isOk()) {
          return ResponseEntity.ok(EchoServiceResponse.success(responseList.get(0)));
        } else if (status.getDescription() != null) {
          return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
              .body(EchoServiceResponse.error(status.getDescription()));
        } else if (status.getCause() != null) {
          return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
              .body(EchoServiceResponse.error(status.getCause().getMessage()));
        } else {
          return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
              .body(EchoServiceResponse.error("Unknown error... Sorry."));
        }
      } catch (InterruptedException e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(
                EchoServiceResponse.error("Interrupted while waiting for gRPC call to complete."));
      }
    }
  }
}
