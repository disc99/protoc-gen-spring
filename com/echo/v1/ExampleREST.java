// Generated by the protoc-spring-rest compiler plugin.  DO NOT EDIT!
// source: example.proto
package com.echo.v1;

import java.util.Map;
import java.util.List;
import com.google.gson.annotations.SerializedName;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.google.protobuf.ByteString;
import java.util.stream.Collectors;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import io.grpc.ManagedChannel;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;
import io.swagger.annotations.ApiOperation;
import java.util.stream.Stream;
import java.util.stream.StreamSupport;
import io.grpc.StatusRuntimeException;
import org.springframework.http.HttpStatus;
import io.grpc.Status;
import io.grpc.Status.Code;
import io.grpc.stub.StreamObserver;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.ArrayList;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.RestController;

@javax.annotation.Generated(
    value = "by protoc-spring-rest compiler plugin",
    comments = "Source: example.proto")
public class ExampleREST {
  @ApiModel(value = "EchoRequest", description = "")
  public static class EchoRequest {
    private EchoRequest() {}

    @ApiModelProperty(required = false, name = "message", value = "")
    @SerializedName(value = "message")
    @JsonProperty(value = "message")
    public String message_ = null;

    @ApiModelProperty(required = false, name = "time", value = "")
    @SerializedName(value = "time")
    @JsonProperty(value = "time")
    public com.google.protobuf.TimestampProtoREST.Timestamp time_ = null;

    public com.echo.v1.EchoRequest toProto() {
      com.echo.v1.EchoRequest.Builder builder = com.echo.v1.EchoRequest.newBuilder();
      if (message_ != null) {
        builder.setMessage(message_);
      }
      if (time_ != null) {
        builder.setTime(time_.toProto());
      }
      return builder.build();
    }

    public static EchoRequest fromProto(com.echo.v1.EchoRequest input) {
      EchoRequest newMsg = new EchoRequest();
      newMsg.message_ = input.getMessage();
      newMsg.time_ = com.google.protobuf.TimestampProtoREST.Timestamp.fromProto(input.getTime());
      return newMsg;
    }
  }

  @ApiModel(value = "EchoResponse", description = "")
  public static class EchoResponse {
    private EchoResponse() {}

    @ApiModelProperty(required = false, name = "message", value = "")
    @SerializedName(value = "message")
    @JsonProperty(value = "message")
    public String message_ = null;

    public com.echo.v1.EchoResponse toProto() {
      com.echo.v1.EchoResponse.Builder builder = com.echo.v1.EchoResponse.newBuilder();
      if (message_ != null) {
        builder.setMessage(message_);
      }
      return builder.build();
    }

    public static EchoResponse fromProto(com.echo.v1.EchoResponse input) {
      EchoResponse newMsg = new EchoResponse();
      newMsg.message_ = input.getMessage();
      return newMsg;
    }
  }

  @Api(value = "/EchoService")
  @RestController
  public static class EchoServiceController {
    @ApiModel(
        description =
            "Wrapper around the responses from EchoService to provide optional error information.")
    public static class EchoServiceResponse<T> {
      @ApiModelProperty("If present, the response from the method call. Null IFF error is present.")
      public final T response;

      @ApiModelProperty(
          "If present, the error encountered during the method call. Null IFF response is present.")
      public final String error;

      private EchoServiceResponse() {
        response = null;
        error = null;
      }

      private EchoServiceResponse(T response, String error) {
        this.response = response;
        this.error = error;
      }

      static <T> EchoServiceResponse success(T response) {
        return new EchoServiceResponse(response, null);
      }

      static <T> EchoServiceResponse error(String error) {
        return new EchoServiceResponse(null, error);
      }
    }

    private com.echo.v1.EchoServiceGrpc.EchoServiceImplBase service;

    public EchoServiceController(com.echo.v1.EchoServiceGrpc.EchoServiceImplBase service) {
      this.service = service;
    }

    @ApiOperation(value = "/EchoService/getEcho", notes = "")
    @RequestMapping(
        path = "/EchoService/getEcho",
        method = RequestMethod.POST,
        consumes = {MediaType.APPLICATION_JSON_UTF8_VALUE},
        produces = {MediaType.APPLICATION_JSON_UTF8_VALUE})
    public ResponseEntity<EchoServiceResponse<com.echo.v1.ExampleREST.EchoResponse>> getEcho(
        @RequestBody com.echo.v1.ExampleREST.EchoRequest inputDto) {
      if (service == null) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(
                EchoServiceResponse.error(
                    "The service EchoService was not injected into the RestController. Check that a bean implementing EchoServiceImplBase exists in the Spring configuration."));
      } // The plugin code should assign a value to this variable inside <prepareInput\>
      final com.echo.v1.EchoRequest input;
      try {
        input = inputDto.toProto();
      } catch (RuntimeException e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(
                EchoServiceResponse.error(
                    "Failed to prepare input for method getEcho: " + e.getMessage()));
      }
      List<com.echo.v1.ExampleREST.EchoResponse> responseList = new ArrayList<>();
      LinkedBlockingQueue<Status> statusQueue = new LinkedBlockingQueue<>(1);
      StreamObserver<com.echo.v1.EchoResponse> responseObserver =
          new StreamObserver<com.echo.v1.EchoResponse>() {
            @Override
            public void onNext(com.echo.v1.EchoResponse value) {
              responseList.add(com.echo.v1.ExampleREST.EchoResponse.fromProto(value));
            }

            @Override
            public void onError(Throwable t) {
              statusQueue.offer(Status.fromThrowable(t));
            }

            @Override
            public void onCompleted() {
              statusQueue.offer(Status.OK);
            }
          };
      try {
        service.getEcho(input, responseObserver);
      } catch (RuntimeException e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(
                EchoServiceResponse.error(
                    "The method getEcho returned an exception: " + e.getMessage()));
      }
      try {
        Status status = statusQueue.take();
        if (status.isOk()) {
          return ResponseEntity.ok(EchoServiceResponse.success(responseList.get(0)));
        } else if (status.getDescription() != null) {
          return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
              .body(EchoServiceResponse.error(status.getDescription()));
        } else if (status.getCause() != null) {
          return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
              .body(EchoServiceResponse.error(status.getCause().getMessage()));
        } else {
          return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
              .body(EchoServiceResponse.error("Unknown error... Sorry."));
        }
      } catch (InterruptedException e) {
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(
                EchoServiceResponse.error("Interrupted while waiting for gRPC call to complete."));
      }
    }
  }
}
